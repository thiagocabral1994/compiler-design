group jasmin;

program(name, functions, prefix) ::= <<
.source <prefix><name>
.class public output/<prefix><name>
.super java/lang/Object
    <functions; separator="\n\n">

    .method public static main([Ljava/lang/String;)V
        .limit stack 1
        invokestatic output/<prefix><name>/<prefix>main()V
        return
    .end method
>>

data(filename, name, fields, prefix) ::= <<
.source <prefix><filename>
.class public output/<prefix><filename>$<prefix><name>
.super java/lang/Object
    <fields; separator="\n">

    .method \<init>()V
        .limit stack 1
        .limit locals 1
        aload_0
        invokespecial java/lang/Object/\<init>()V
        return
    .end method
>>

field(type, name, prefix) ::= ".field <prefix><name> <type>"
param(type) ::= "<type>"

function_void(name, prefix, params, locals, commands, stack) ::= <<
.method static <prefix><name>(<params>)V
    .limit stack <stack>
    .limit locals <locals>
    
    <if(commands)><commands; separator="\n\n"><endif>
    return
.end method
>>

function(name, prefix, params, locals, commands, stack) ::= <<
.method static <prefix><name>(<params>)[Ljava/lang/Object
    .limit stack <stack>
    .limit locals <locals>
    
    <if(commands)><commands; separator="\n\n"><endif>
.end method
>>

array_type(type) ::= "[<type>"
int_type() ::= "I"
float_type() ::= "F"
boolean_type() ::= "Z"
char_type() ::= "C"
custom_type(filename, name, prefix) ::= "Loutput/<prefix><filename>$<prefix><name>;"

print_int(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/print(I)V
>>

print_float(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/print(F)V
>>

print_bool(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/print(Z)V
>>

print_char(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/print(C)V
>>

read_int(lvalue, scanner) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_<scanner>
aload_<scanner>
invokevirtual java/util/Scanner/nextInt()I
istore_<lvalue>
aload_<scanner>
invokevirtual java/util/Scanner/close()V
>>


read_float(lvalue, scanner) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_<scanner>
aload_<scanner>
invokevirtual java/util/Scanner/nextFloat()F
fstore_<lvalue>
aload_<scanner>
invokevirtual java/util/Scanner/close()V
>>


read_bool(lvalue, scanner) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_<scanner>
aload_<scanner>
invokevirtual java/util/Scanner/nextBoolean()Z
istore_<lvalue>
aload_<scanner>
invokevirtual java/util/Scanner/close()V
>>


read_char(lvalue, scanner) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_<scanner>
aload_<scanner>
invokevirtual java/util/Scanner/next()Ljava/lang/String;
iconst_0
invokevirtual java/lang/String/charAt(I)C
istore_<lvalue>
aload_<scanner>
invokevirtual java/util/Scanner/close()V
>>

return(exps, size, size_label) ::= <<
iconst_<size>
anewarray java/lang/Object
astore_<size_label> 

<exps: { exp | 
aload_<size_label>
iconst_<i0>
<exp>
aastore
}; separator="\n\n">

aload_<size_label>
areturn
>>

list_command(commands) ::= <<
<if(commands)><commands; separator="\n"><endif>
>>

if(num, exp, thn, els) ::= <<
<exp>
ifeq #<num>
<thn>
goto #<num>#end
#<num>:
<els>
#<num>#end:
nop
>>

iterate(exp, thn, label_iterator) ::= <<
iconst_0
istore <label_iterator>

#start_loop:
iload <label_iterator>
bipush <exp>
if_icmpge #end_loop
<thn>
iinc <label_iterator> 1
goto #start_loop

#end_loop
>>

assignment_int(lvalue, exp) ::= <<
<exp>
istore_<lvalue>
>>

assignment_float(lvalue, exp) ::= <<
<exp>
fstore_<lvalue>
>>

assignment_char(lvalue, exp) ::= <<
<exp>
istore_<lvalue>
>>

assignment_bool(lvalue, exp) ::= <<
<exp>
istore_<lvalue>
>>

lvalue_label(label) ::= "<label>"

lvalue_int(label) ::= <<
iload_<label>
>>

lvalue_float(label) ::= <<
fload_<label>
>>

lvalue_bool(label) ::= <<
iload_<label>
>>

lvalue_char(label) ::= <<
iload_<label>
>>

array_lvalue(lvalue, exp) ::= <<
    <exp>
    <lvalue>
    iadd
>>

object_lvalue(lvalue, name, prefix) ::= <<
aload <lvalue>
getfield <prefix><name>
>>

float_exp(value) ::= "ldc <value>"
int_exp(value) ::= "sipush <value>"
char_exp(value) ::= "bipush <value>"
null_exp() ::= "aconst_null"
true_exp() ::= "iconst_1"
false_exp() ::= "iconst_0"

new_exp(type, exp, offset) ::= <<>>

call_void(class, func_name, args, args_types, prefix) ::= <<
<args; separator="\n">
invokestatic <prefix><class>/<prefix><func_name>(args_types)V
>>

call_return(name, args, prefix, rv_count, call_return_assignments) ::= <<

>>

call_return_assignment(declarations, class, lvalue, func_name, params_types, prefix) ::= <<

>>

call_exp(class, func_name, args, args_types, prefix, return_types) ::= <<
<args; separator="\n">
invokestatic <prefix><class>/<prefix><func_name>(args_types)[Ljava/lang/Object
>>

parenthesis_exp(exp) ::= <<>>

mult_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
imul
>>

mult_float(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
fmul
>>

div_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
idiv
>>

mod_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
irem
>>

add_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
iadd
>>

sub_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
isub
>>

lt_int(num, left_exp, right_exp) ::= <<
<right_exp>
<left_exp>
isub
ifgt #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

lt_float(num, left_exp, right_exp) ::= <<
<right_exp>
<left_exp>
fsub
ifgt #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

equals_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
isub
ifeq #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

equals_float(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
fsub
ifeq #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

not_equals_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
isub
ifeq #<num>
iconst_1
goto #<num>#<num>
#<num>:
iconst_0
#<num>#<num>:
>>

not_equals_float(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
fsub
ifeq #<num>
iconst_1
goto #<num>#<num>
#<num>:
iconst_0
#<num>#<num>:
>>

and_exp(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
iand
>>

not_exp(exp) ::= <<
<exp>
iconst_1
ixor
>>

neg_int(exp) ::= <<
<exp>
iconst_0
isub
>>

neg_float(exp) ::= <<
<exp>
fconst_0
fsub
>>