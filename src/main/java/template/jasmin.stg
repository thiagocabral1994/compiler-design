group jasmin;

program(name, functions, prefix) ::= <<
.source <prefix><name>
.class public output/<prefix><name>
.super java/lang/Object
    <functions; separator="\n\n">

    .method public static main([Ljava/lang/String;)V
        .limit stack 1
        invokestatic output/<prefix><name>/<prefix>main()V
        return
    .end method
>>

data(filename, name, fields, prefix) ::= <<
.source <prefix><filename>
.class public output/<prefix><filename>$<prefix><name>
.super java/lang/Object
    <fields; separator="\n">

    .method \<init>()V
        .limit stack 1
        .limit locals 1
        aload_0
        invokespecial java/lang/Object/\<init>()V
        return
    .end method
>>

field(type, name, prefix) ::= ".field <prefix><name> <type>"
param(type) ::= "<type>"

function_void(name, prefix, params, locals, commands, stack) ::= <<
.method static <prefix><name>(<params>)V
    .limit stack <stack>
    .limit locals <locals>
    
    <if(commands)><commands; separator="\n\n"><endif>
    return
.end method
>>

function(name, prefix, params, locals, commands, stack) ::= <<
.method static <prefix><name>(<params>)[Ljava/lang/Object;
    .limit stack <stack>
    .limit locals <locals>
    
    <if(commands)><commands; separator="\n\n"><endif>
.end method
>>

array_type(type) ::= "[<type>"
int_type() ::= "I"
float_type() ::= "F"
boolean_type() ::= "Z"
char_type() ::= "C"
custom_type(filename, name, prefix) ::= "Loutput/<prefix><filename>$<prefix><name>;"

print_int(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/print(I)V
>>

print_float(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/print(F)V
>>

print_bool(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/print(Z)V
>>

print_char(exp) ::= <<
getstatic java/lang/System/out Ljava/io/PrintStream;
<exp>
invokevirtual java/io/PrintStream/print(C)V
>>

read_int(lvalue, scanner) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_<scanner>
aload_<scanner>
invokevirtual java/util/Scanner/nextInt()I
istore_<lvalue>
aload_<scanner>
invokevirtual java/util/Scanner/close()V
>>


read_float(lvalue, scanner) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_<scanner>
aload_<scanner>
invokevirtual java/util/Scanner/nextFloat()F
fstore_<lvalue>
aload_<scanner>
invokevirtual java/util/Scanner/close()V
>>


read_bool(lvalue, scanner) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_<scanner>
aload_<scanner>
invokevirtual java/util/Scanner/nextBoolean()Z
istore_<lvalue>
aload_<scanner>
invokevirtual java/util/Scanner/close()V
>>


read_char(lvalue, scanner) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_<scanner>
aload_<scanner>
invokevirtual java/util/Scanner/next()Ljava/lang/String;
iconst_0
invokevirtual java/lang/String/charAt(I)C
istore_<lvalue>
aload_<scanner>
invokevirtual java/util/Scanner/close()V
>>

return(exps, size, size_label) ::= <<
iconst_<size>
anewarray java/lang/Object
astore <size_label> 

<exps; separator="\n\n">

aload <size_label>
areturn
>>

return_attr(size_label, index, exp, return_attr_type) ::= <<
aload <size_label>
iconst_<index>
<exp>
<return_attr_type>
aastore
>>

return_attr_int() ::= <<
invokestatic java/lang/Integer/valueOf(I)Ljava/lang/Integer;
>>

return_attr_char() ::= <<
invokestatic java/lang/Character/valueOf(C)Ljava/lang/Character;
>>

return_attr_bool() ::= <<
invokestatic java/lang/Boolean/valueOf(Z)Ljava/lang/Boolean;
>>

return_attr_float() ::= <<
invokestatic java/lang/Float/valueOf(F)Ljava/lang/Float;
>>

list_command(commands) ::= <<
<if(commands)><commands; separator="\n"><endif>
>>

if(num, exp, thn, els) ::= <<
<exp>
ifeq #<num>
<thn>
goto #<num>#end
#<num>:
<els>
#<num>#end:
nop
>>

iterate(exp, thn, label_iterator) ::= <<
iconst_0
istore <label_iterator>

#start_loop:
iload <label_iterator>
bipush <exp>
if_icmpge #end_loop
<thn>
iinc <label_iterator> 1
goto #start_loop

#end_loop
>>

assignment_int(lvalue, exp) ::= <<
<exp>
istore_<lvalue>
>>

assignment_float(lvalue, exp) ::= <<
<exp>
fstore_<lvalue>
>>

assignment_char(lvalue, exp) ::= <<
<exp>
istore_<lvalue>
>>

assignment_bool(lvalue, exp) ::= <<
<exp>
istore_<lvalue>
>>

lvalue_label(label) ::= "<label>"

lvalue_int(label) ::= <<
iload_<label>
>>

lvalue_float(label) ::= <<
fload_<label>
>>

lvalue_bool(label) ::= <<
iload_<label>
>>

lvalue_char(label) ::= <<
iload_<label>
>>

array_lvalue(lvalue, exp) ::= <<
    <exp>
    <lvalue>
    iadd
>>

object_lvalue(lvalue, name, prefix) ::= <<
aload <lvalue>
getfield <prefix><name>
>>

float_exp(value) ::= "ldc <value>"
int_exp(value) ::= "sipush <value>"
char_exp(value) ::= "bipush <value>"
null_exp() ::= "aconst_null"
true_exp() ::= "iconst_1"
false_exp() ::= "iconst_0"

new_exp(type, exp, offset) ::= <<>>

call_void(args, prefix, filename, name, param_types) ::= <<
; Carregando os argumentos do método
<args; separator="\n">

; Invocação estática do método
invokestatic output/<prefix><filename>/<prefix><name>(<param_types>)V
>>

call_void_return_pop(args, prefix, filename, name, param_types) ::= <<
; Carregando os argumentos do método
<args; separator="\n">

; Invocação estática do método
invokestatic output/<prefix><filename>/<prefix><name>(<param_types>)[Ljava/lang/Object;
pop
>>

call_return(args, prefix, filename, name, param_types, return_size, return_attr) ::= <<
; Carregando os argumentos do método
<args; separator="\n">

; Invocação estática do método
invokestatic output/<prefix><filename>/<prefix><name>(<param_types>)[Ljava/lang/Object;
astore_<return_size>

<return_attr; separator="\n\n">
>>

call_return_attr(return_size, store, index, cast) ::= <<
; Atribuição do retorno da função
aload_<return_size>
iconst_<index>
aaload
<cast>
<store>_<index>
>>

call_exp(args, prefix, filename, name, param_types, return_type, exp, cast) ::= <<
; Carregando os argumentos do método
<args; separator="\n">

; Invocação estática do método
invokestatic output/<prefix><filename>/<prefix><name>(<param_types>)<return_type>

; Atribuição do retorno da função
iconst_<exp>
aaload
<cast>
>>

cast_char() ::= <<
checkcast java/lang/Character
invokevirtual java/lang/Character/charValue()C
>>

cast_int() ::= <<
checkcast java/lang/Integer
invokevirtual java/lang/Integer/intValue()I
>>

cast_float() ::= <<
checkcast java/lang/Float
invokevirtual java/lang/Float/floatValue()F
>>

cast_bool() ::= <<
checkcast java/lang/Boolean
invokevirtual java/lang/Boolean/booleanValue()Z
>>

parenthesis_exp(exp) ::= <<>>

mult_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
imul
>>

mult_float(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
fmul
>>

div_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
idiv
>>

mod_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
irem
>>

add_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
iadd
>>

sub_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
isub
>>

lt_int(num, left_exp, right_exp) ::= <<
<right_exp>
<left_exp>
isub
ifgt #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

lt_float(num, left_exp, right_exp) ::= <<
<right_exp>
<left_exp>
fsub
ifgt #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

equals_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
isub
ifeq #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

equals_float(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
fsub
ifeq #<num>
iconst_0
goto #<num>#<num>
#<num>:
iconst_1
#<num>#<num>:
>>

not_equals_int(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
isub
ifeq #<num>
iconst_1
goto #<num>#<num>
#<num>:
iconst_0
#<num>#<num>:
>>

not_equals_float(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
fsub
ifeq #<num>
iconst_1
goto #<num>#<num>
#<num>:
iconst_0
#<num>#<num>:
>>

and_exp(left_exp, right_exp) ::= <<
<left_exp>
<right_exp>
iand
>>

not_exp(exp) ::= <<
<exp>
iconst_1
ixor
>>

neg_int(exp) ::= <<
<exp>
iconst_0
isub
>>

neg_float(exp) ::= <<
<exp>
fconst_0
fsub
>>